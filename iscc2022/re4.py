b = [0x9A, 0x78, 0xB6, 0x12, 0xBE, 0x66, 0x8D, 0xCF, 0x51, 0x9E, 0x63, 0xCB, 0x4A, 0xD1, 0x1A, 0x59, 0x78, 0x1C, 0x17, 0x73,0xF2, 0x1D, 0x05, 0x2F, 0xF0, 0xD7, 0xB3, 0x22, 0x5D, 0xAD, 0x0B, 0xE2] 
c = [0xE4,0x33,0xD2,0x4B,0xF7,0x0C,0xA3,0x8B,0x3F,0xCC,0x14,0x8C,0x64,0x97,0x4E,0x0A,0x3E,0x4B,0x51,0x07,0x8F,0x79,0x60,0x5B,0x9B] # 这里填写是base64解码后的hex 来源是有个qmemcpy函数那里
m = [] 
for i in range(len(c)): 
	m.append(c[i]^b[i])
key = [0x32, 0x63, 0x65, 0x61, 0x39, 0x66, 0x30, 0x34, 0x63, 0x36, 0x33, 0x62, 0x34, 0x32, 0x38, 0x33, 0x39, 0x34, 0x30, 0x65, 0x63, 0x30, 0x65, 0x36, 0x64, 0x32, 0x39, 0x62, 0x65, 0x32, 0x38, 0x64] 
def lll(a,b): 
	if a>b: 
		return 0 
	else: 
		return -1 
f = ''
for i in range(len(m)): 
	for j in range(128): 
		if (lll((key[i]+0xd0)&0xff,0xa) + j +2)&0xff == m[i]:
			f += chr(j)
			print(f) 
			break 
p = list(f[::-1])

print()
def ppp(num):
	a = num&1
	return a==0
for i in range(len(p)): 
	if ord('a')<=ord(p[i])<=ord('z'): 
		p[i] = chr(ord(p[i])^0x20)
	elif ord('A')<=ord(p[i])<=ord('Z'): 
		p[i] = chr(ord(p[i])^0x20)
	elif ord('0') <=ord(p[i])<=ord('9'):
		a = ord(p[i]) + 1
		b = ord(p[i]) - 1
		if ppp(ord(p[i])):
			p[i] = chr(a)
		else:
			p[i] = chr(b)
	else:
		pass
for i in range(len(p)):
	print(p[i],end='')
